

###################################
#ESTABLECE EL DIRECTORIO DE TRABAJO
###################################
#DIRECTORIO DE TRABAJO
dir_trabajo<-'C:/sesion_7_reto_final/'
#ESTABLECE EL DIRECTORIO DE TRABAJO
setwd(dir_trabajo)

getwd()


################################
#INSTALACION Y CARGA DE PAQUETES
################################
#NOTA: SOLO ES NECESARIO INSTALARLOS UNA VEZ. DESACTIVA ESTAS L칈NEAS PARA LA PR칍XIMA SESI칍N
#INSTALA PAQUETE DISMO Y TODAS SUS DEPENDENCIAS (EJECUTAR UNA SOLA VEZ)
install.packages("dismo", dep=TRUE) #SDMs con R
install.packages("plotmo", dep=TRUE) #curvas de respuesta
install.packages("randomForest", dep=TRUE) #random forest
install.packages("party", dep=TRUE) #치rboles de inferencia condicional
install.packages("HH", dep=TRUE) #VIF
install.packages("tree", dep=TRUE) #치rboles de regresi칩n

#CARGA LAS LIBRERIAS NECESARIAS (EJECUTAR SIEMPRE QUE TRABAJES CON EL SCRIPT)
library(dismo)
library(plotmo)
library(randomForest)
library(party)
library(HH)
library(tree)
library(rgdal)


##################################
#IMPORTA LAS VARIABLES PREDICTORAS
##################################
#LISTADO DE VARIABLES
# se cargan las variables de los distintos a絪s: presente, 2020, 2030, 2040, 2050. Las de 2060 tienen un error y no se pueden cargar.
lista_variables <- list.files(path="variables/presente",pattern='*.asc', full.names=TRUE)
lista_variables2020 <- list.files(path="variables/futuro_A2/2020",pattern='*.asc', full.names=TRUE)
lista_variables2030 <- list.files(path="variables/futuro_A2/2030",pattern='*.asc', full.names=TRUE)
lista_variables2040 <- list.files(path="variables/futuro_A2/2040",pattern='*.asc', full.names=TRUE)
lista_variables2050 <- list.files(path="variables/futuro_A2/2050",pattern='*.asc', full.names=TRUE)


#stack Y brick PREPARAN LAS VARIABLES EN UN UNICO OBJETO ESPACIAL
help(brick) #mapas en memoria, m치s r치pido (pero usa mucha RAM)
help(stack) #mapas en disco, m치s lento (pero usa menos RAM)
variables <- brick(stack(lista_variables))
variables2020 <- brick(stack(lista_variables2020))
variables2030 <- brick(stack(lista_variables2030))
variables2040 <- brick(stack(lista_variables2040))
variables2050 <- brick(stack(lista_variables2050))

#Creacion de la mascara
# esto es para que todas las variables tengan la misma extensi蚤, la que queremos es la de Sierra Nevada, las variables de estos paquetes tiene extensi蚤 de Andalucia, por eso hacemos esto.
help(raster)
r<-raster("mascara.asc")
help(crop)
variables_sn<-crop(variables, r)
plot(variables_sn)

variables2020_sn<-crop(variables2020,r)
variables2030_sn<-crop(variables2030,r)
variables2040_sn<-crop(variables2040,r)
variables2050_sn<-crop(variables2050,r)

# con esto se pintan las variables de todos los a絪s
plot(variables2020_sn)
plot(variables2030_sn)
plot(variables2040_sn)
plot(variables2050_sn)


#DIBUJA LAS VARIABLES PREDICTORAS
png("variables_sn.png", width=2000, height=2000, pointsize=20)
plot(variables_sn)
dev.off()

png("variables2020_sn.png", width=2000, height=2000, pointsize=20)
plot(variables2020_sn)





#####################################################
#ANALISIS DE CORRELACION DE LAS VARIABLES PREDICTORAS
#####################################################
# SE QUIEREN LAS VARIABLES QUE NO TENGAN UNA ALTA CORRELACION PARA QUE NO SE GENERE INFORMACION REDUNDANTE, PORQUE EXPLICARIA LO MISMO
#TRANSFORMA LOS MAPAS EN UNA TABLA
variables_tabla<-as.data.frame(variables_sn)

#ELIMINA LOS VALORES NULOS
variables_tabla<-na.omit(variables_tabla)

#MATRIZ DE CORRELACION
help(cor)
variables_correlacion<-cor(variables_tabla)

#MATRIZ DE DISTANCIAS ('ABS' = VALOR ABSOLUTO, PARA ELIMINAR CORRELACIONES NEGATIVAS)
help(as.dist)
help(abs)
variables_dist<-abs(as.dist(variables_correlacion))

#CLUSTER DE VARIABLES SEGUN LA DISTANCIA (MENOR DISTANCIA = MAYOR CORRELACION)
help(hclust)
variables_cluster<-hclust(1-variables_dist)

#GRAFICO DEL CLUSTER DE CORRELACIONES 
plot(variables_cluster)

#GRAFICO DEL CLUSTER DE CORRELACIONES EXPORTADO A PDF
pdf("correlacion.pdf", width=8, height=11.5, pointsize=20)
plot(variables_cluster)
dev.off()

#SELECCIONAMOS LAS VARIABLES CON LAS QUE QUEREMOS TRABAJAR
# estas son las variables que seleccionamos 
variables_tabla2<-data.frame(variables_tabla$PA,variables_tabla$topo_posic,variables_tabla$sol_rad_sum,variables_tabla$huella_humana,variables_tabla$PV,variables_tabla$topo_pend)

names(variables_tabla2)<-c("PA","topo_posic","sol_rad_sum","huella_humana","PV","topo_pend")



##########################################################
#PREPARACION DE LAS TABLAS DE DATOS PARA HACER LOS MODELOS
##########################################################
#UNA TABLA DE DATOS REQUIERE:
#una columna llamada presencia, con 1 en las presencias y 0 en las ausencias
#tantas columnas como variables predictivas se van a usar, y en cada registro, el valor de la variable para cada uno de los puntos de presencia
#las columnas con las coordenadas (no son necesarias para ajustar los modelos, pero si lo son para evaluarlos)



#IMPORTA REGISTROS DE PRESENCIA
#------------------------------
#importa la tabla
presencia_utm<-read.table("enebral/presencia_enebral.csv",header=T, sep=';')

## Convertir coordenadas UTM a Geograficas

presencia_utm_f <- SpatialPoints(cbind(presencia_utm$UTM_X_GPS,presencia_utm$UTM_Y_GPS), 
                             proj4string=CRS("+proj=utm +zone=30"))

# Convierto objeto a longitud+latitud 
presencia_geo <- as.data.frame(spTransform(presencia_utm_f, CRS("+proj=longlat")))


#IMPORTA REGISTROS DE AUSENCIA
#-----------------------------

ausencia_utm<-read.table("enebral/ausencia_enebral.txt",header=T, sep=';')

## Convertir coordenadas UTM a Geogr치ficas

ausencia_utm_f <- SpatialPoints(cbind(ausencia_utm$UTM_X_GPS,ausencia_utm$UTM_Y_GPS), 
                              proj4string=CRS("+proj=utm +zone=30"))

# Convierto objeto a longitud+latitud 
ausencia_geo <- as.data.frame(spTransform(ausencia_utm_f, CRS("+proj=longlat")))



#EXTRAE VALORES DE LAS VARIABLES EN LOS PUNTOS DE PRESENCIA A UNA TABLA
help(extract)
presencia_variables<-data.frame(extract(variables_sn, presencia_geo))
str(presencia_variables)
presencia_variables$respuesta <- rep(1, nrow(presencia_variables))

#EXTRAE LOS VALORES DE LAS VARIABLES EN LAS AUSENCIAS
ausencia_variables<-data.frame(extract(variables_sn, ausencia_geo))
ausencia_variables$respuesta <- rep(0, nrow(ausencia_variables))


#UNE LA RESPUESTA, LAS VARIABLES Y LAS COORDENADAS EN UN SOLO DATAFRAME
tabla_completa<-rbind(ausencia_variables, presencia_variables)



#QUITAMOS LOS REGISTROS CON VALORES NULOS (QUE NO TIENEN DATOS PARA TODAS LAS VARIABLES)
tabla_completa<-na.omit(tabla_completa)

#VEMOS EL RESULTADO

head(tabla_completa)


# Computamos una regresion logistica con todos nuestras variables y con los datos de presencia/ausencia

help(glm)
m1<-glm(respuesta ~.,data=tabla_completa)
summary(m1)

# seleccionamos las variables que son significativas. Los "estimate" nos dan idea de la ganancia de cada variable.
tabla_modelo <-tabla_completa[,c('huella_humana','PA','PV','topo_posic','respuesta')]

m2<-glm(respuesta~., data=tabla_modelo)
summary(m2)

# valores predichos. Ya tenemos nuestro modelo matematico, ahora vamos a aplicarlo a las variables (mapas) que teniamos al principio.
# proyectar el modelo estad押tico al  conjunto de variables


p<-predict(variables_sn, m2)
plot(p)
p2020<-predict(variables2020_sn, m2)
plot(p2020)
p2030<-predict(variables2030_sn, m2)
plot(p2030)
p2040<-predict(variables2040_sn, m2)
plot(p2040)
p2050<-predict(variables2050_sn, m2)
plot(p2050)


# Generar mapa en formato .asc
p_raster<-raster(p)
help(writeRaster)
writeRaster(p, "enebral_presente.asc")
            






